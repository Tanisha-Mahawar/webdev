<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particle Heart</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205; /* Deep cosmic black */
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Hide the raw webcam feed */
        .input_video {
            display: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 40px;
            box-sizing: border-box;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.5rem;
            color: #ff5e78;
            text-shadow: 0 0 15px #ff5e78;
            transition: opacity 0.5s ease;
        }

        .controls-info {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 20px;
            border-radius: 12px;
            max-width: 350px;
            border-left: 4px solid #ff5e78;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.4rem; color: #ff9fb0; }
        p { margin: 5px 0; font-size: 0.9rem; color: #ddd; }
        .highlight { color: #fff; font-weight: bold; }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading">Initialize AI & Physics...<br><small>Please allow camera access</small></div>

    <!-- UI -->
    <div id="ui-layer">
        <div class="controls-info">
            <h1>Particle Heart</h1>
            <p>üëã <span class="highlight">Move Hand</span> to rotate & rotate.</p>
            <p>‚ÜïÔ∏è <span class="highlight">Depth</span> push/pull to zoom.</p>
            <p>‚ú® <span class="highlight">Touch</span> particles to drag them.</p>
        </div>
    </div>

    <!-- Hidden Video for MediaPipe -->
    <video class="input_video"></video>
    
    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- CDN Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ==========================================
        // 1. CONFIGURATION
        // ==========================================
        const CONFIG = {
            particleCount: 4000,
            heartSize: 15,    // Size of the heart shape
            colorBase: 0xff0040, // Deep Red
            colorHighlight: 0xff8fa3, // Pinkish
            interactionRadius: 8.0, // Radius of hand influence
        };

        // State management
        const state = {
            handDetected: false,
            targetRotX: 0,
            targetRotY: 0,
            targetZ: 0,
            handWorldPos: new THREE.Vector3(1000, 1000, 1000), // Default far away
            handVelocity: new THREE.Vector3(0, 0, 0)
        };

        // ==========================================
        // 2. THREE.JS SETUP
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02); // Distance fog

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Perf optimization
        container.appendChild(renderer.domElement);

        // ==========================================
        // 3. PARTICLE SYSTEM (THE HEART)
        // ==========================================
        
        // Generate Texture Programmatically (Soft Glow)
        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,100,100,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        const geometry = new THREE.BufferGeometry();
        const positions = [];   // Current positions
        const origins = [];     // Target "Home" positions (Heart shape)
        const velocities = [];  // Physics velocity
        const colors = [];
        const sizes = [];

        const color1 = new THREE.Color(CONFIG.colorBase);
        const color2 = new THREE.Color(CONFIG.colorHighlight);

        // Heart Math: Rejection Sampling for volumetric look
        // Formula: (x^2 + 9/4y^2 + z^2 - 1)^3 - x^2z^3 - 9/80y^2z^3 < 0
        let i = 0;
        while (i < CONFIG.particleCount) {
            const range = 1.5;
            const x = (Math.random() * 2 - 1) * range;
            const y = (Math.random() * 2 - 1) * range;
            const z = (Math.random() * 2 - 1) * range;

            // Heart Equation
            const a = x*x + (9/4)*y*y + z*z - 1;
            const val = a*a*a - x*x*z*z*z - (9/80)*y*y*z*z*z;

            if (val < 0) {
                // Point is inside heart!
                
                // Scale and Rotate to be upright.
                // Original formula puts Y as up, but it looks better scaled.
                const px = x * CONFIG.heartSize;
                const py = z * CONFIG.heartSize; // Swap Y/Z for upright orientation check
                const pz = y * (CONFIG.heartSize * 0.5); // Flatten depth slightly

                // We need to rotate roughly 90deg on X to make it stand up properly 
                // relative to camera, or just map x, z, y manually:
                // Let's use: X=x, Y=z, Z=y
                
                const finalX = x * CONFIG.heartSize;
                const finalY = z * CONFIG.heartSize; // Points up
                const finalZ = y * (CONFIG.heartSize * 0.8); 

                positions.push(finalX, finalY, finalZ); // Current
                origins.push(finalX, finalY, finalZ);   // Target
                velocities.push(0, 0, 0);

                // Color Gradient (Bottom dark, top light)
                const alpha = (z + 1) / 2; // Normalized height roughly
                const c = color1.clone().lerp(color2, alpha + Math.random()*0.2);
                colors.push(c.r, c.g, c.b);

                // Size variation
                sizes.push(0.3 + Math.random() * 0.7);

                i++;
            }
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        // Store origins/velocities in simpler arrays for CPU access
        const originArr = new Float32Array(origins);
        const velocityArr = new Float32Array(velocities);

        const material = new THREE.PointsMaterial({
            size: 1.0,
            vertexColors: true,
            map: getTexture(),
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // ==========================================
        // 4. MEDIAPIPE HAND TRACKING
        // ==========================================
        const videoElement = document.getElementsByClassName('input_video')[0];
        
        function onHandsResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. Calculate Center of Hand (Index Knuckle)
                const x = landmarks[9].x; 
                const y = landmarks[9].y;
                const z = landmarks[9].z; // Relative depth

                // 2. Map Screen Coords to Rotation (Global Manipulation)
                // Center is 0.5. Range -0.5 to 0.5
                state.targetRotY = (x - 0.5) * 2.5; // Rotate around Y
                state.targetRotX = (y - 0.5) * 2.0; // Rotate around X

                // 3. Map Z to Push/Pull
                state.targetZ = z * -30; // Scale depth

                // 4. Calculate 3D World Position for Particle Interaction
                // We unproject the 2D screen pos to 3D world pos
                const vector = new THREE.Vector3(
                    (1 - x) * 2 - 1, // Flip X for mirror feel
                    -(y * 2 - 1),    // Flip Y standard
                    0.5              // Unproject depth (approx)
                );
                
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = 40; // Approx distance to heart center
                const newPos = camera.position.clone().add(dir.multiplyScalar(distance));

                // Calculate Hand Velocity for "Drag/Flow" effect
                state.handVelocity.subVectors(newPos, state.handWorldPos);
                state.handWorldPos.copy(newPos);

            } else {
                state.handDetected = false;
                // Reset slightly
                state.targetRotX = 0;
                state.targetRotY = 0;
                state.targetZ = 0;
                state.handWorldPos.set(1000, 1000, 1000); // Move away
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onHandsResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // ==========================================
        // 5. ANIMATION LOOP & PHYSICS
        // ==========================================
        const clock = new THREE.Clock();
        
        // Helper to transform global hand pos to local heart space
        // This ensures physics work even when heart is rotated
        function getLocalHandPos() {
            const invRotX = -particleSystem.rotation.x;
            const invRotY = -particleSystem.rotation.y;
            
            // Clone hand pos
            const p = state.handWorldPos.clone();
            // Undo object position translation (if any)
            p.sub(particleSystem.position);
            // Apply inverse rotation
            p.applyEuler(new THREE.Euler(invRotX, invRotY, 0, 'XYZ'));
            return p;
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            
            // --- A. Smooth Global Transform ---
            const smooth = 0.1;
            particleSystem.rotation.x += (state.targetRotX - particleSystem.rotation.x) * smooth;
            particleSystem.rotation.y += (state.targetRotY - particleSystem.rotation.y) * smooth;
            // Simple breathing animation on scale
            const breath = 1 + Math.sin(time * 2) * 0.02;
            particleSystem.scale.set(breath, breath, breath);
            // Push/Pull
            particleSystem.position.z += (state.targetZ - particleSystem.position.z) * smooth;

            // --- B. Particle Physics on CPU ---
            const posArr = geometry.attributes.position.array;
            const localHand = getLocalHandPos();
            const handVel = state.handVelocity; // Vector of movement

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 1. Current state
                let px = posArr[ix];
                let py = posArr[iy];
                let pz = posArr[iz];
                
                let vx = velocityArr[ix];
                let vy = velocityArr[iy];
                let vz = velocityArr[iz];

                // 2. Home Force (Spring back to heart shape)
                const ox = originArr[ix];
                const oy = originArr[iy];
                const oz = originArr[iz];

                const dx = ox - px;
                const dy = oy - py;
                const dz = oz - pz;

                vx += dx * 0.03; // Spring strength
                vy += dy * 0.03;
                vz += dz * 0.03;

                // 3. Hand Interaction (Magnetic Flow)
                const hdx = px - localHand.x;
                const hdy = py - localHand.y;
                const hdz = pz - localHand.z;
                const distSq = hdx*hdx + hdy*hdy + hdz*hdz;

                // Interaction Check
                if (distSq < (CONFIG.interactionRadius * CONFIG.interactionRadius)) {
                    const dist = Math.sqrt(distSq);
                    const force = (CONFIG.interactionRadius - dist) / CONFIG.interactionRadius; 

                    // a. Attraction (Pull towards hand center)
                    vx -= hdx * 0.05 * force;
                    vy -= hdy * 0.05 * force;
                    vz -= hdz * 0.05 * force;

                    // b. Flow/Drag (Add hand velocity)
                    // If hand is moving, drag particles with it
                    vx += handVel.x * 2.0 * force;
                    vy += handVel.y * 2.0 * force;
                    vz += handVel.z * 2.0 * force;
                }

                // 4. Noise/Turbulence (Visual interest)
                vx += Math.sin(time * 3 + py * 0.5) * 0.01;
                vy += Math.cos(time * 3 + px * 0.5) * 0.01;

                // 5. Integration & Damping
                vx *= 0.92; // Friction
                vy *= 0.92;
                vz *= 0.92;

                px += vx;
                py += vy;
                pz += vz;

                // Write back
                posArr[ix] = px;
                posArr[iy] = py;
                posArr[iz] = pz;
                velocityArr[ix] = vx;
                velocityArr[iy] = vy;
                velocityArr[iz] = vz;
            }

            geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>